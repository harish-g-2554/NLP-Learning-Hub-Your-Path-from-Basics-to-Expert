<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Module 2 — Text Processing & Regular Expressions</title>
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700;800&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="{{ url_for('static', filename='styles.css') }}">
<head>
  <!-- ... your other head elements ... -->
  <style>
    .page-nav {
      padding: 12px 24px;
      background: rgba(17, 18, 28, 0.4);
      border-bottom: 1px solid #273041;
      margin-bottom: 24px;
    }
    .page-nav a {
      color: #cbd5ff;
      text-decoration: none;
      font-weight: 600;
      font-size: 0.9rem;
    }
    .page-nav a:hover {
      text-decoration: underline;
    }
    /* ... rest of your styles ... */
  </style>
</head>
<body>
  <div class="scene">
    <header class="page-nav">
      <a href="{{ url_for('modules') }}">&larr; Back to All Modules</a>
    </header>
  <style>
    /* Page-specific refinements (keeps your theme) */
    .lesson-wrap{max-width:1200px;margin:0 auto;padding:8px 16px 96px}
    .modules-hero{max-width:960px;margin:0 auto 18px;text-align:center}
    .modules-title{font-size:clamp(1.8rem,4.8vw,3rem);margin:8px 0 6px}
    .modules-hero p{color:#9fb0d8}

    .term{margin:18px 0;padding:22px;border-radius:16px;background:linear-gradient(180deg,rgba(17,18,28,.75),rgba(17,18,28,.45));border:1px solid #273041;box-shadow:0 10px 30px #0003,0 0 0 1px #1f2333 inset}
    .term h2{margin:0 0 8px;color:#e6e8ff}
    .t-desc{color:#9aa6d1; line-height: 1.6;}
    .twocol{display:grid;grid-template-columns:1.1fr 1fr;gap:18px;margin-top:10px}
    @media (max-width:900px){.twocol{grid-template-columns:1fr}}

    .diagram{padding:12px;border:1px solid #2b3449;border-radius:12px;background:rgba(12,14,22,.45);margin:10px 0}
    .d-caption{font-size:.82rem;color:#91a0c7;margin-bottom:6px;font-weight:700}
    .pill-row{display:flex;gap:8px;flex-wrap:wrap}
    .pill{background:rgba(124,58,237,.08);border:1px solid rgba(124,58,237,.25);color:#e5e8ff;padding:6px 10px;border-radius:10px}
    .txt{width:100%;border-radius:12px;border:1px solid #2b3449;background:#0f1220;color:#e8ebff;padding:10px}
    .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace}

    .table{width:100%;border-collapse:separate;border-spacing:0 6px}
    .table th,.table td{padding:10px 12px;vertical-align:top}
    .table thead th{color:#cbd5ff;text-align:left;border-bottom:1px solid #2b3449}
    .table tbody tr{background:rgba(12,14,22,.55);border:1px solid #2b3449}
    .table tbody tr td:first-child{border-radius:8px 0 0 8px}
    .table tbody tr td:last-child{border-radius:0 8px 8px 0}
    .table code { background: rgba(124,58,237,.1); color: #e5e8ff; padding: 2px 5px; border-radius: 4px; }

    .btn.primary{padding:10px 16px;border-radius:10px}
    .hint{opacity:.75}

    .match-list{display:grid;grid-template-columns:1fr;gap:6px}
    .match-item{background:rgba(17,18,28,.6);border:1px solid #273041;border-radius:10px;padding:8px 10px}
    .markwrap{padding:10px;border:1px dashed #334155;border-radius:10px;background:#0f1220;color:#e8ebff;white-space:pre-wrap}
    mark{background:rgba(124,58,237,.28);padding:0 2px;border-radius:4px; color: #fff;}
    .infobox{background:linear-gradient(180deg,rgba(6,182,212,.08),rgba(124,58,237,.08));border:1px solid #334155;border-radius:12px;padding:10px 12px;color:#bdd3f4}
  </style>
</head>
<body>
  <div class="scene">
    <header class="modules-hero">
      <h1 class="modules-title">Module 2: <span>Text Processing & Regular Expressions</span></h1>
      <p class="modules-sub">Clean text like a pro, then master RegEx to slice, match, extract, and transform patterns.</p>
    </header>

    <main class="lesson-wrap">

      <!-- WHAT & WHY -->
      <section class="term" id="intro">
        <h2>What is Text Processing? What are Regular Expressions?</h2>
        <div class="twocol">
          <div>
            <p class="t-desc">
              <strong>Text processing</strong> is the series of steps we take to clean and prepare raw text before feeding it to an NLP model. Think of it like a chef preparing ingredients before cooking. Raw text from the web is often messy—it contains HTML tags, weird spacing, emojis, and inconsistencies. Processing fixes this, so our models can focus on the actual meaning.
            </p>
            <div class="diagram">
              <div class="d-caption">Common preprocessing steps</div>
              <div class="pill-row">
                <span class="pill">Normalize Unicode</span>
                <span class="pill">Convert to Lowercase</span>
                <span class="pill">Fix Whitespace</span>
                <span class="pill">Strip HTML/XML tags</span>
                <span class="pill">Handle Emojis</span>
                <span class="pill">Expand "don't" to "do not"</span>
              </div>
            </div>
          </div>
          <div>
            <p class="t-desc">
              <strong>Regular Expressions (RegEx)</strong> are a special language for finding and manipulating text based on patterns. Instead of searching for a fixed word like "cat", you can search for a pattern like "any three-letter word starting with 'c'". They are incredibly powerful for extracting specific, structured information from text, like dates, emails, or phone numbers.
            </p>
            <div class="infobox">
                <strong>Analogy:</strong> Think of RegEx as the "Find and Replace" feature in a text editor, but on steroids. It's a "find" that works with patterns, not just exact text.
            </div>
          </div>
        </div>
      </section>

      <!-- CHEAT SHEET + USE CASES -->
      <section class="term" id="cheat">
        <h2>Regular Expressions — A Beginner's Guide to the Syntax</h2>
        <p class="t-desc">This is your reference for all the core building blocks of RegEx. Each part is explained with a simple analogy and a real-world use case.</p>
        <div class="diagram">
          <table class="table mono">
            <thead>
                <tr>
                    <th>Token</th>
                    <th>Beginner's Explanation</th>
                    <th>Example</th>
                    <th>Use Case</th>
                </tr>
            </thead>
            <tbody>
              <tr>
                <td><code>.</code></td>
                <td>The "any character" wildcard. It's a placeholder that can match any single character (letter, number, symbol), except a newline.</td>
                <td><code>h.t</code> matches "hot", "hat", "h8t".</td>
                <td>Finding words with slight variations, like <code>gr.y</code> to match "gray" or "grey".</td>
              </tr>
              <tr>
                <td><code>\d</code> / <code>\D</code></td>
                <td><code>\d</code> matches any digit (0-9). <code>\D</code> matches anything that is NOT a digit.</td>
                <td><code>\d{4}</code> matches "2025".</td>
                <td>Extracting years, postal codes (<code>\d{5}</code>), or any number from text.</td>
              </tr>
              <tr>
                <td><code>\w</code> / <code>\W</code></td>
                <td><code>\w</code> matches any "word" character (a-z, A-Z, 0-9, and underscore). <code>\W</code> is the opposite.</td>
                <td><code>\w+</code> matches a whole word.</td>
                <td>Extracting usernames or hashtags, like <code>@\w+</code>.</td>
              </tr>
              <tr>
                <td><code>\s</code> / <code>\S</code></td>
                <td><code>\s</code> matches any whitespace (space, tab, newline). <code>\S</code> is the opposite.</td>
                <td><code>\s+</code> finds one or more spaces.</td>
                <td>Cleaning up text by replacing multiple spaces with a single space.</td>
              </tr>
              <tr>
                <td><code>[abc]</code></td>
                <td>A character set. It matches exactly one of the characters inside the brackets.</td>
                <td><code>gr[ae]y</code> matches "gray" or "grey".</td>
                <td>Matching words with regional spelling differences.</td>
              </tr>
              <tr>
                <td><code>[^abc]</code></td>
                <td>A negated character set. It matches any character that is NOT inside the brackets.</td>
                <td><code>[^0-9]</code> matches any non-digit.</td>
                <td>Finding the first character in a string that isn't a vowel.</td>
              </tr>
              <tr>
                <td><code>[a-z]</code></td>
                <td>A range. It lets you specify a sequence of characters without typing them all out.</td>
                <td><code>[A-Za-z0-9]</code> matches any letter or number.</td>
                <td>Validating if a username contains only alphanumeric characters.</td>
              </tr>
              <tr>
                <td><code>^</code> / <code>$</code></td>
                <td>Anchors. <code>^</code> matches the start of a string, and <code>$</code> matches the end.</td>
                <td><code>^Hello$</code> only matches "Hello", not "Hello world".</td>
                <td>Validating input that must be an exact format, like a 5-digit ZIP code (<code>^\d{5}$</code>).</td>
              </tr>
              <tr>
                <td><code>\b</code> / <code>\B</code></td>
                <td>Word boundary. <code>\b</code> is a zero-width anchor that matches the position between a word character and a non-word character.</td>
                <td><code>\bcat\b</code> matches "cat" but not "caterpillar".</td>
                <td>Ensuring you search for whole words only.</td>
              </tr>
              <tr>
                <td><code>+</code></td>
                <td>"One or more" of the preceding token.</td>
                <td><code>\d+</code> matches "1", "12", "123", etc.</td>
                <td>Extracting numbers of any length.</td>
              </tr>
              <tr>
                <td><code>*</code></td>
                <td>"Zero or more" of the preceding token.</td>
                <td><code>\w*</code> can match "" (empty string) or "word".</td>
                <td>Finding an optional part of a pattern, like a file extension.</td>
              </tr>
              <tr>
                <td><code>?</code></td>
                <td>"Zero or one" of the preceding token. Makes it optional.</td>
                <td><code>colou?r</code> matches both "color" and "colour".</td>
                <td>Handling optional characters in a pattern.</td>
              </tr>
              <tr>
                <td><code>{m,n}</code></td>
                <td>A specific quantifier. <code>{3}</code> means exactly 3 times, <code>{2,4}</code> means 2 to 4 times, <code>{2,}</code> means 2 or more.</td>
                <td><code>\d{2,4}</code> matches "12", "123", "1234".</td>
                <td>Enforcing length constraints, like a 4-digit year (<code>\d{4}</code>).</td>
              </tr>
              <tr>
                <td><code>(...)</code></td>
                <td>A capturing group. It "saves" the part of the string that it matches, so you can extract it later.</td>
                <td><code>(\d{4})-(\d{2})-(\d{2})</code></td>
                <td>Extracting year, month, and day from a date into separate variables.</td>
              </tr>
              <tr>
                <td><code>(?:...)</code></td>
                <td>A non-capturing group. It groups tokens together but doesn't "save" the match.</td>
                <td><code>(?:https?):\/\/</code></td>
                <td>Grouping parts of a pattern for a quantifier (like <code>?</code>) without creating a capture group you don't need.</td>
              </tr>
              <tr>
                <td><code>\1, \2</code></td>
                <td>A backreference. It refers to the text captured by a previous group. <code>\1</code> refers to the first group, <code>\2</code> to the second, and so on.</td>
                <td><code>(\w+)\s+\1</code> finds repeated words.</td>
                <td>Finding accidental duplicate words like "the the".</td>
              </tr>
              <tr>
                <td><code>|</code></td>
                <td>Alternation, or "OR". It matches either the expression before or the expression after it.</td>
                <td><code>cat|dog</code> matches "cat" or "dog".</td>
                <td>Matching one of several possible keywords.</td>
              </tr>
              <tr>
                <td><code>(?=...)</code></td>
                <td>Positive lookahead. It checks if a pattern exists *after* the current position, but doesn't include it in the match.</td>
                <td><code>\w+(?=\.)</code> matches a word only if it's followed by a period.</td>
                <td>Matching a password that must contain a special character, without including that character in the main match.</td>
              </tr>
              <tr>
                <td><code>(?<=...)</code></td>
                <td>Positive lookbehind. It checks if a pattern exists *before* the current position, but doesn't include it in the match.</td>
                <td><code>(?<=\$)\d+</code> matches numbers that follow a dollar sign.</td>
                <td>Extracting currency values without including the "$" symbol.</td>
              </tr>
            </tbody>
          </table>
        </div>
      </section>

      <!-- PRACTICE LAB (GLOBAL FIND ONLY) -->
      <section class="term" id="lab">
        <h2>Practice Lab — Try your own RegEx</h2>
        <p class="t-desc">We always search in <b>global</b> mode to list all non‑overlapping matches. Type a pattern and see it work live!</p>

        <div class="twocol">
          <div>
            <div class="diagram">
              <div class="d-caption">Your pattern</div>
              <input id="rePattern" class="txt mono" placeholder="e.g., \b([A-Za-z]+)\b" value="([A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,})">
              <div style="margin-top:10px">
                <button class="btn primary" id="btnRunFind" type="button">Run</button>
              </div>
            </div>

            <div class="diagram">
              <div class="d-caption">Text</div>
              <textarea id="reText" class="txt" rows="8">Contact us for support. Alice's email is alice@example.com. Bob's is bob@web-domain.co.uk. For sales, contact sales@my-company.net. Invalid one: test@.com. The meeting is on 2024-08-12.</textarea>
            </div>
          </div>

          <div>
            <div class="diagram">
              <div class="d-caption">Matches</div>
              <div id="matchList" class="match-list"></div>
            </div>
            <div class="diagram">
              <div class="d-caption">Highlighted</div>
              <div id="highlightBox" class="markwrap"></div>
            </div>
            <div class="diagram">
              <div class="d-caption">Errors</div>
              <div id="reError" class="t-desc hint">None</div>
            </div>
          </div>
        </div>
      </section>

      <!-- QUIZ -->
      <section class="term">
        <h2>Quick Quiz (10 Questions)</h2>
        <details class="qa"><summary><span class="qnum">1.</span> How do you match the whole word "win" but not "window" or "swimming"?</summary><div class="answer mono">\bwin\b</div></details>
        <details class="qa"><summary><span class="qnum">2.</span> How do you capture the three parts of a date like "YYYY-MM-DD"?</summary><div class="answer mono">(\d{4})-(\d{2})-(\d{2})</div></details>
        <details class="qa"><summary><span class="qnum">3.</span> What's the pattern for "color" or "colour"?</summary><div class="answer mono">colou?r</div></details>
        <details class="qa"><summary><span class="qnum">4.</span> How do you find a number that comes immediately after a dollar sign ($)?</summary><div class="answer mono">(?&lt;=\$)\d+</div></details>
        <details class="qa"><summary><span class="qnum">5.</span> What single token matches any character that is NOT a digit?</summary><div class="answer mono">\D</div></details>
        <details class="qa"><summary><span class="qnum">6.</span> How would you find a word that is repeated twice in a row (e.g., "hello hello")?</summary><div class="answer mono">(\w+)\s+\1</div></details>
        <details class="qa"><summary><span class="qnum">7.</span> What pattern validates a 5-digit US ZIP code and nothing else on the line?</summary><div class="answer mono">^\d{5}$</div></details>
        <details class="qa"><summary><span class="qnum">8.</span> How do you match the words "cat", "bat", or "rat"?</summary><div class="answer mono">[cbr]at</div></details>
        <details class="qa"><summary><span class="qnum">9.</span> What does the `+` quantifier mean?</summary><div class="answer">It means "one or more" of the previous character or group.</div></details>
        <details class="qa"><summary><span class="qnum">10.</span> What is the difference between `.` and `\.` in a regex pattern?</summary><div class="answer">The dot <code>.</code> is a wildcard for any character. The backslash escapes it so <code>\.</code> matches a literal dot character.</div></details>
      </section>

    </main>
  </div>

  <script>
    // ---- Helpers ----
    async function postJSON(url, payload) {
      const res = await fetch(url, {
        method: 'POST',
        headers: {'Content-Type':'application/json'},
        body: JSON.stringify(payload),
      });
      let data = null; try { data = await res.json(); } catch(e) {}
      if (!res.ok) {
        const msg = (data && data.error) ? data.error : `HTTP ${res.status}`;
        throw new Error(msg);
      }
      return data;
    }
    function escapeHtml(s) {
      return s.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;')
              .replace(/"/g,'&quot;').replace(/'/g,'&#39;');
    }

    // ---- UI elements ----
    const elPattern = document.getElementById('rePattern');
    const elText    = document.getElementById('reText');
    const elRun     = document.getElementById('btnRunFind');
    const elErr     = document.getElementById('reError');
    const elList    = document.getElementById('matchList');
    const elHi      = document.getElementById('highlightBox');

    async function runFind() {
      const pattern = elPattern.value;
      const text = elText.value;

      // FIX: Check for empty pattern before making API call
      if (!pattern.trim()) {
          elErr.textContent = 'None';
          elList.innerHTML = '<div class="hint">No matches found. (Empty pattern)</div>';
          elHi.textContent = text;
          return; // Stop execution
      }

      elErr.textContent = '…';
      elList.innerHTML = '';
      elHi.textContent = text;

      try {
        // Always "global": backend returns all matches
        const data = await postJSON('/api/regex/find', { pattern, text });

        // List matches
        if (!data.matches || data.matches.length === 0) {
          elList.innerHTML = '<div class="hint">No matches found.</div>';
        } else {
          elList.innerHTML = data.matches.map((m, i) => {
            const groups = []
              .concat((m.groups || []).map((g,idx)=>`<span class="pill">#${idx+1}=${escapeHtml(String(g ?? ''))}</span>`))
              .concat(Object.entries(m.named || {}).map(([k,v])=>`<span class="pill"><b>${k}</b>=${escapeHtml(String((v && v[0]) ?? ''))}</span>`))
              .join(' ');
            return `<div class="match-item"><div><b>${i+1}.</b> <code class="mono">${escapeHtml(m.match)}</code> at [${m.start}..${m.end})</div>
                    <div class="pill-row" style="margin-top:6px">${groups || '<span class="hint">no capture groups</span>'}</div></div>`;
          }).join('');
        }

        // Highlight (non-overlapping)
        const segs = [];
        let last = 0;
        (data.matches || []).forEach(m => {
          segs.push(escapeHtml(text.slice(last, m.start)));
          segs.push('<mark>' + escapeHtml(text.slice(m.start, m.end)) + '</mark>');
          last = m.end;
        });
        segs.push(escapeHtml(text.slice(last)));
        elHi.innerHTML = segs.join('');
        elErr.textContent = 'None';
      } catch (e) {
        elErr.textContent = e.message;
      }
    }

    elRun.addEventListener('click', runFind);
    window.addEventListener('load', runFind);
  </script>
</body>
</html>
